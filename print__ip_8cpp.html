<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>print_ip: C:/Users/etreh/Documents/Programming/Otus/C++_Developer/Professional/lesson_7/otus_cpp_prof_hw4/source/print_ip.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">print_ip<span id="projectnumber">&#160;0.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_b2f33c71d4aa5e7af42a1ca61ff5af1b.html">source</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">print_ip.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;type_traits&gt;</code><br />
<code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &lt;list&gt;</code><br />
<code>#include &lt;tuple&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structis__tuple.html">is_tuple&lt; Tuple &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to determine if a type is a tuple.  <a href="structis__tuple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structis__tuple_3_01std_1_1tuple_3_01_types_8_8_8_01_4_01_4.html">is_tuple&lt; std::tuple&lt; Types... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structis__tuple.html" title="Trait to determine if a type is a tuple.">is_tuple</a> for std::tuple types.  <a href="structis__tuple_3_01std_1_1tuple_3_01_types_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structis__same__type_3_01std_1_1tuple_3_01_type_01_4_01_4.html">is_same_type&lt; std::tuple&lt; Type &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structis__same__type.html" title="Trait to determine if all elements in a tuple are of the same type.">is_same_type</a> for a tuple with a single type. This specialization sets the value to <code>true_type</code> for a tuple with a single type.  <a href="structis__same__type_3_01std_1_1tuple_3_01_type_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structis__same__type_3_01std_1_1tuple_3_01_type_00_01_type_00_01_types_8_8_8_01_4_01_4.html">is_same_type&lt; std::tuple&lt; Type, Type, Types... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursive specialization of <a class="el" href="structis__same__type.html" title="Trait to determine if all elements in a tuple are of the same type.">is_same_type</a> to check if all types in a tuple are the same. This specialization recursively checks each type in the tuple to ensure they are all the same.  <a href="structis__same__type_3_01std_1_1tuple_3_01_type_00_01_type_00_01_types_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structis__same__type_3_01std_1_1tuple_3_01_type_00_01_enother_type_00_01_types_8_8_8_01_4_01_4.html">is_same_type&lt; std::tuple&lt; Type, EnotherType, Types... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structis__same__type.html" title="Trait to determine if all elements in a tuple are of the same type.">is_same_type</a> for tuples with different types. This specialization sets the value to <code>false_type</code> if any two types in the tuple are different.  <a href="structis__same__type_3_01std_1_1tuple_3_01_type_00_01_enother_type_00_01_types_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af26f05fadbdba2382fb7600f6ba8795b" id="r_af26f05fadbdba2382fb7600f6ba8795b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af26f05fadbdba2382fb7600f6ba8795b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_integral&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af26f05fadbdba2382fb7600f6ba8795b">print_ip</a> (T value)</td></tr>
<tr class="memdesc:af26f05fadbdba2382fb7600f6ba8795b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the IP address representation of an integral value.  <br /></td></tr>
<tr class="separator:af26f05fadbdba2382fb7600f6ba8795b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8371439e16692edbf66724ef396a5a" id="r_aae8371439e16692edbf66724ef396a5a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aae8371439e16692edbf66724ef396a5a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; T, std::string &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aae8371439e16692edbf66724ef396a5a">print_ip</a> (T value)</td></tr>
<tr class="memdesc:aae8371439e16692edbf66724ef396a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the IP address representation of an string value.  <br /></td></tr>
<tr class="separator:aae8371439e16692edbf66724ef396a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9997a25931527d343682b8169992bac" id="r_ad9997a25931527d343682b8169992bac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad9997a25931527d343682b8169992bac"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::disjunction_v&lt; std::is_same&lt; T, std::vector&lt; typenameT::value_type &gt; &gt;, std::is_same&lt; T, std::list&lt; typenameT::value_type &gt; &gt; &gt;, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad9997a25931527d343682b8169992bac">print_ip</a> (const T &amp;container)</td></tr>
<tr class="memdesc:ad9997a25931527d343682b8169992bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the IP address representation of elements in a container.  <br /></td></tr>
<tr class="separator:ad9997a25931527d343682b8169992bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5ceac3be9fde4c825dbabfae961de1" id="r_aaa5ceac3be9fde4c825dbabfae961de1"><td class="memTemplParams" colspan="2">template&lt;typename Tuple , std::size_t... index&gt; </td></tr>
<tr class="memitem:aaa5ceac3be9fde4c825dbabfae961de1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaa5ceac3be9fde4c825dbabfae961de1">print_tuple</a> (const Tuple &amp;t, std::index_sequence&lt; index... &gt;)</td></tr>
<tr class="memdesc:aaa5ceac3be9fde4c825dbabfae961de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the elements of a tuple as an IP address. This helper function prints each element of a tuple in dot-separated format.  <br /></td></tr>
<tr class="separator:aaa5ceac3be9fde4c825dbabfae961de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebdca554dd038788c16cd0417e9bf633" id="r_aebdca554dd038788c16cd0417e9bf633"><td class="memTemplParams" colspan="2">template&lt;typename Tuple &gt; </td></tr>
<tr class="memitem:aebdca554dd038788c16cd0417e9bf633"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structis__tuple.html">is_tuple</a>&lt; Tuple &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aebdca554dd038788c16cd0417e9bf633">print_ip</a> (const Tuple &amp;value)</td></tr>
<tr class="memdesc:aebdca554dd038788c16cd0417e9bf633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a tuple as an IP address if it contains elements of the same type. This function ensures that the tuple is printed only if all its elements are of the same type. This function uses <code>std::enable_if</code> to ensure it is only instantiated with tuple types. It also uses a static assertion to ensure all elements in the tuple are of the same type.  <br /></td></tr>
<tr class="separator:aebdca554dd038788c16cd0417e9bf633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66f6b31b5ad750f1fe042a706a4e3d4" id="r_ae66f6b31b5ad750f1fe042a706a4e3d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a> ()</td></tr>
<tr class="separator:ae66f6b31b5ad750f1fe042a706a4e3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae66f6b31b5ad750f1fe042a706a4e3d4" name="ae66f6b31b5ad750f1fe042a706a4e3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae66f6b31b5ad750f1fe042a706a4e3d4">&#9670;&#160;</a></span>main()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad9997a25931527d343682b8169992bac" name="ad9997a25931527d343682b8169992bac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9997a25931527d343682b8169992bac">&#9670;&#160;</a></span>print_ip() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::disjunction_v&lt; std::is_same&lt; T, std::vector&lt; typenameT::value_type &gt; &gt;, std::is_same&lt; T, std::list&lt; typenameT::value_type &gt; &gt; &gt;, void &gt;::type print_ip </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the IP address representation of elements in a container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the container. Must be either std::vector or std::list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>The container whose elements are to be printed as an IP address.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebdca554dd038788c16cd0417e9bf633" name="aebdca554dd038788c16cd0417e9bf633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebdca554dd038788c16cd0417e9bf633">&#9670;&#160;</a></span>print_ip() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structis__tuple.html">is_tuple</a>&lt; Tuple &gt;::value, void &gt;::type print_ip </td>
          <td>(</td>
          <td class="paramtype">const Tuple &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a tuple as an IP address if it contains elements of the same type. This function ensures that the tuple is printed only if all its elements are of the same type. This function uses <code>std::enable_if</code> to ensure it is only instantiated with tuple types. It also uses a static assertion to ensure all elements in the tuple are of the same type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tuple</td><td>The type of the tuple.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The tuple to be printed.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af26f05fadbdba2382fb7600f6ba8795b" name="af26f05fadbdba2382fb7600f6ba8795b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af26f05fadbdba2382fb7600f6ba8795b">&#9670;&#160;</a></span>print_ip() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_integral&lt; T &gt;::value, void &gt;::type print_ip </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the IP address representation of an integral value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the input value. Must be an integral type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The integral value to be printed as an IP address.</td></tr>
  </table>
  </dd>
</dl>
<p>Example usage: </p><div class="fragment"><div class="line"><a class="code hl_function" href="#af26f05fadbdba2382fb7600f6ba8795b">print_ip</a>(int8_t{-1}); <span class="comment">// 255</span></div>
<div class="line"><a class="code hl_function" href="#af26f05fadbdba2382fb7600f6ba8795b">print_ip</a>(int16_t{0}); <span class="comment">// 0.0</span></div>
<div class="line"><a class="code hl_function" href="#af26f05fadbdba2382fb7600f6ba8795b">print_ip</a>(int32_t{2130706433}); <span class="comment">// 127.0.0.1</span></div>
<div class="line"><a class="code hl_function" href="#af26f05fadbdba2382fb7600f6ba8795b">print_ip</a>(int64_t{8875824491850138409});<span class="comment">// 123.45.67.89.101.112.131.41</span></div>
<div class="ttc" id="aprint__ip_8cpp_html_af26f05fadbdba2382fb7600f6ba8795b"><div class="ttname"><a href="#af26f05fadbdba2382fb7600f6ba8795b">print_ip</a></div><div class="ttdeci">std::enable_if&lt; std::is_integral&lt; T &gt;::value, void &gt;::type print_ip(T value)</div><div class="ttdoc">Prints the IP address representation of an integral value.</div><div class="ttdef"><b>Definition</b> print_ip.cpp:22</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aae8371439e16692edbf66724ef396a5a" name="aae8371439e16692edbf66724ef396a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae8371439e16692edbf66724ef396a5a">&#9670;&#160;</a></span>print_ip() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt; T, std::string &gt;::value, void &gt;::type print_ip </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the IP address representation of an string value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the input value. Must be an string type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string value to be printed as an IP address.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa5ceac3be9fde4c825dbabfae961de1" name="aaa5ceac3be9fde4c825dbabfae961de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa5ceac3be9fde4c825dbabfae961de1">&#9670;&#160;</a></span>print_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tuple , std::size_t... index&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void print_tuple </td>
          <td>(</td>
          <td class="paramtype">const Tuple &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; index... &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the elements of a tuple as an IP address. This helper function prints each element of a tuple in dot-separated format. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tuple</td><td>The type of the tuple.</td></tr>
    <tr><td class="paramname">...index</td><td>The indices of the tuple elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The tuple to be printed.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
